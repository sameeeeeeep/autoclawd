# UI Polish Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Fix contrast, readability, responsiveness, broken logs, and add Light/Dark/System appearance toggle — surgical fixes only, no layout redesign.

**Architecture:** `Color.adaptive(light:dark:)` via `NSColor(dynamicProvider:)` makes all AppTheme tokens dark-mode-aware with zero changes to individual views. A new `ColorSchemeSetting` enum in `SettingsManager` drives `.preferredColorScheme()` via a thin `AppearanceWrapper` view in `MainPanelWindow`. Logs are fixed to read from `AutoClawdLogger.shared.snapshot()` (in-memory, always populated) and fall back to `~/.autoclawd/logs/autoclawd-YYYY-MM-DD.log`.

**Tech Stack:** Swift 5.9, SwiftUI, AppKit (NSColor, NSHostingView). Build with `make` from repo root — no Xcode or SPM. No unit tests; build success = passing.

---

## Task 1: AppTheme — adaptive tokens, Color.adaptive(), fixes

**Files:**
- Modify: `Sources/AppTheme.swift` (full rewrite)

**Context:**
`Color.adaptive(light:dark:)` uses `NSColor(name:dynamicProvider:)` which hooks into macOS's appearance system. When `.preferredColorScheme(.dark)` is applied to a SwiftUI view tree, macOS switches the appearance to `NSAppearance.Name.darkAqua`, and the dynamic provider fires, returning the dark colour. All existing views automatically get the right colour with zero changes.

**Step 1: Replace `Sources/AppTheme.swift` with this content**

```swift
// Sources/AppTheme.swift
import AppKit
import SwiftUI

// MARK: - App Design Tokens

enum AppTheme {
    // MARK: Colors (all adaptive — light/dark)
    static let background     = Color.adaptive(light: Color(hex: "#FFFFFF"), dark: Color(hex: "#0F0F0F"))
    static let surface        = Color.adaptive(light: Color(hex: "#F0F0F0"), dark: Color(hex: "#1A1A1A"))
    static let surfaceHover   = Color.adaptive(light: Color(hex: "#E5E5E5"), dark: Color(hex: "#252525"))
    static let textPrimary    = Color.adaptive(light: Color(hex: "#0A0A0A"), dark: Color(hex: "#F0F0F0"))
    static let textSecondary  = Color.adaptive(light: Color(hex: "#525252"), dark: Color(hex: "#A0A0A0"))
    static let textDisabled   = Color.adaptive(light: Color(hex: "#B0B0B0"), dark: Color(hex: "#4A4A4A"))
    static let green          = Color(hex: "#16C172")
    static let cyan           = Color(hex: "#06B6D4")
    static let border         = Color.adaptive(light: Color(hex: "#D4D4D4"), dark: Color(hex: "#2E2E2E"))
    static let destructive    = Color(hex: "#EF4444")

    // MARK: Typography
    static let caption  = Font.system(size: 12, weight: .regular)
    static let body     = Font.system(size: 13, weight: .regular)
    static let label    = Font.system(size: 13, weight: .medium)
    static let heading  = Font.system(size: 15, weight: .semibold)
    static let title    = Font.system(size: 18, weight: .bold)
    static let mono     = Font.system(size: 12, design: .monospaced)

    // MARK: Spacing (8px grid)
    static let xs:  CGFloat = 4
    static let sm:  CGFloat = 8
    static let md:  CGFloat = 12
    static let lg:  CGFloat = 16
    static let xl:  CGFloat = 24
    static let xxl: CGFloat = 32

    // MARK: Geometry
    static let cornerRadius:        CGFloat = 6
    static let sidebarWidth:        CGFloat = 60
    static let selectedAccentWidth: CGFloat = 3
}

// MARK: - Color Hex Init

extension Color {
    init(hex: String) {
        let hex = hex.trimmingCharacters(in: CharacterSet.alphanumerics.inverted)
        var int: UInt64 = 0
        Scanner(string: hex).scanHexInt64(&int)
        let r = Double((int >> 16) & 0xFF) / 255
        let g = Double((int >>  8) & 0xFF) / 255
        let b = Double( int        & 0xFF) / 255
        self.init(red: r, green: g, blue: b)
    }

    static func adaptive(light: Color, dark: Color) -> Color {
        Color(NSColor(name: nil, dynamicProvider: { appearance in
            appearance.bestMatch(from: [.darkAqua, .aqua]) == .darkAqua
                ? NSColor(dark) : NSColor(light)
        }))
    }
}

// MARK: - Button Styles

struct PrimaryButtonStyle: ButtonStyle {
    func makeBody(configuration: Configuration) -> some View {
        configuration.label
            .font(AppTheme.label)
            .foregroundColor(.white)
            .padding(.horizontal, AppTheme.md)
            .padding(.vertical, AppTheme.sm)
            .background(AppTheme.textPrimary.opacity(configuration.isPressed ? 0.75 : 1))
            .cornerRadius(AppTheme.cornerRadius)
    }
}

struct RunButtonStyle: ButtonStyle {
    func makeBody(configuration: Configuration) -> some View {
        configuration.label
            .font(AppTheme.label)
            .foregroundColor(AppTheme.textPrimary)
            .padding(.horizontal, AppTheme.md)
            .padding(.vertical, AppTheme.sm)
            .background(AppTheme.green.opacity(configuration.isPressed ? 0.75 : 1))
            .cornerRadius(AppTheme.cornerRadius)
    }
}

struct SecondaryButtonStyle: ButtonStyle {
    func makeBody(configuration: Configuration) -> some View {
        configuration.label
            .font(AppTheme.label)
            .foregroundColor(AppTheme.textPrimary)
            .padding(.horizontal, AppTheme.md)
            .padding(.vertical, AppTheme.sm)
            .background(AppTheme.background)
            .overlay(RoundedRectangle(cornerRadius: AppTheme.cornerRadius)
                        .stroke(AppTheme.border, lineWidth: 1))
            .opacity(configuration.isPressed ? 0.7 : 1)
    }
}

struct DestructiveButtonStyle: ButtonStyle {
    func makeBody(configuration: Configuration) -> some View {
        configuration.label
            .font(AppTheme.label)
            .foregroundColor(AppTheme.destructive)
            .padding(.horizontal, AppTheme.md)
            .padding(.vertical, AppTheme.sm)
            .background(AppTheme.background)
            .overlay(RoundedRectangle(cornerRadius: AppTheme.cornerRadius)
                        .stroke(AppTheme.destructive, lineWidth: 1))
            .opacity(configuration.isPressed ? 0.7 : 1)
    }
}
```

**Step 2: Build**

```bash
make
```
Expected: `Built build/AutoClawd.app` — no errors.

**Step 3: Commit**

```bash
git add Sources/AppTheme.swift
git commit -m "feat: adaptive dark/light tokens in AppTheme, fix contrast values, caption 12pt"
```

---

## Task 2: SettingsManager — ColorSchemeSetting

**Files:**
- Modify: `Sources/SettingsManager.swift`

**Context:**
`SettingsManager` already has `AppearanceMode` (frosted/transparent/dynamic) for something else — don't touch it. Add a new separate `ColorSchemeSetting` enum for light/dark/system. Follow the exact same pattern as `transcriptionMode` (raw string stored in `UserDefaults.standard`).

**Step 1: Add the enum and stored property to `Sources/SettingsManager.swift`**

After the closing `}` of `AppearanceMode` (around line 34) add:

```swift
enum ColorSchemeSetting: String, CaseIterable {
    case system = "system"
    case light  = "light"
    case dark   = "dark"

    var displayName: String {
        switch self {
        case .system: return "System"
        case .light:  return "Light"
        case .dark:   return "Dark"
        }
    }

    var preferredColorScheme: ColorScheme? {
        switch self {
        case .system: return nil
        case .light:  return .light
        case .dark:   return .dark
        }
    }
}
```

Then inside the `SettingsManager` class, add after the `kAppearanceMode` key (around line 50):

```swift
private let kColorScheme = "color_scheme_setting"
```

And add the property after the `synthesizeThreshold` block:

```swift
var colorSchemeSetting: ColorSchemeSetting {
    get {
        let raw = defaults.string(forKey: kColorScheme) ?? ColorSchemeSetting.system.rawValue
        return ColorSchemeSetting(rawValue: raw) ?? .system
    }
    set { defaults.set(newValue.rawValue, forKey: kColorScheme) }
}
```

**Step 2: Build**

```bash
make
```
Expected: `Built build/AutoClawd.app` — no errors.

**Step 3: Commit**

```bash
git add Sources/SettingsManager.swift
git commit -m "feat: add ColorSchemeSetting enum to SettingsManager"
```

---

## Task 3: MainPanelWindow — apply preferredColorScheme reactively

**Files:**
- Modify: `Sources/MainPanelWindow.swift`

**Context:**
`MainPanelWindow` creates an `NSHostingView(rootView: MainPanelView(...))`. To make `.preferredColorScheme()` reactive (updates live when user changes the picker), wrap `MainPanelView` in a thin `AppearanceWrapper` view that reads from `@AppStorage`. `@AppStorage` triggers a SwiftUI re-render when the value changes.

**Step 1: Replace `Sources/MainPanelWindow.swift` with:**

```swift
import AppKit
import SwiftUI

// MARK: - Appearance Wrapper
// Reads @AppStorage so the color scheme re-applies whenever the setting changes.
private struct AppearanceWrapper: View {
    @AppStorage("color_scheme_setting") private var schemeSetting: String = "system"
    let appState: AppState

    private var preferredScheme: ColorScheme? {
        switch ColorSchemeSetting(rawValue: schemeSetting) ?? .system {
        case .system: return nil
        case .light:  return .light
        case .dark:   return .dark
        }
    }

    var body: some View {
        MainPanelView(appState: appState)
            .preferredColorScheme(preferredScheme)
    }
}

// MARK: - MainPanelWindow

final class MainPanelWindow: NSWindow {

    init(appState: AppState) {
        super.init(
            contentRect: NSRect(x: 0, y: 0, width: 800, height: 580),
            styleMask: [.titled, .closable, .resizable, .miniaturizable, .fullSizeContentView],
            backing: .buffered,
            defer: false
        )
        title = "AutoClawd"
        titlebarAppearsTransparent = false
        isReleasedWhenClosed = false
        minSize = NSSize(width: 700, height: 480)
        center()

        contentView = NSHostingView(rootView: AppearanceWrapper(appState: appState))
    }
}
```

**Step 2: Build**

```bash
make
```
Expected: `Built build/AutoClawd.app` — no errors.

**Step 3: Commit**

```bash
git add Sources/MainPanelWindow.swift
git commit -m "feat: reactive preferredColorScheme via AppearanceWrapper in MainPanelWindow"
```

---

## Task 4: MainPanelView — sidebar labels + width

**Files:**
- Modify: `Sources/MainPanelView.swift`

**Context:**
The sidebar is 52px wide with icon-only buttons. Users have no idea what `globe`, `brain.head.profile`, and `gearshape` mean without hovering for the tooltip. Add a small text label below each icon and widen sidebar to 60px (already updated in AppTheme.sidebarWidth).

**Step 1: In `Sources/MainPanelView.swift`, find the sidebar button label block and add the text label**

Find this block inside the sidebar `ForEach`:
```swift
Image(systemName: tab.icon)
    .font(.system(size: 18, weight: selectedTab == tab ? .semibold : .regular))
    .foregroundColor(selectedTab == tab ? AppTheme.textPrimary : AppTheme.textSecondary)
    .frame(maxWidth: .infinity)
```

Replace with:
```swift
VStack(spacing: 3) {
    Image(systemName: tab.icon)
        .font(.system(size: 16, weight: selectedTab == tab ? .semibold : .regular))
        .foregroundColor(selectedTab == tab ? AppTheme.textPrimary : AppTheme.textSecondary)
    Text(tab.rawValue)
        .font(.system(size: 9, weight: .medium))
        .foregroundColor(selectedTab == tab ? AppTheme.textPrimary : AppTheme.textSecondary)
}
.frame(maxWidth: .infinity)
```

Note: `AppTheme.sidebarWidth` is already 60 from Task 1, so no width change needed here.

**Step 2: Build**

```bash
make
```
Expected: `Built build/AutoClawd.app` — no errors.

**Step 3: Commit**

```bash
git add Sources/MainPanelView.swift
git commit -m "fix: add sidebar tab labels, reduce icon size to 16pt"
```

---

## Task 5: WorldView — readability + responsiveness

**Files:**
- Modify: `Sources/WorldView.swift`

**Context:**
Three problems:
1. `textSecondary.opacity(0.4)` for out-of-month day cells — use `AppTheme.textDisabled` instead
2. `lineLimit(1)` on todo content — truncates without showing full task
3. `frame(maxHeight: 200)` on unscheduled scroll view — arbitrarily squishes the list; replace with `layoutPriority` so the calendar and todo list share space proportionally, with a generous cap

**Step 1: Fix `textSecondary.opacity(0.4)` in `DayCell`**

Find in `DayCell.body`:
```swift
isCurrentMonth ? AppTheme.textPrimary : AppTheme.textSecondary.opacity(0.4)
```

Replace with:
```swift
isCurrentMonth ? AppTheme.textPrimary : AppTheme.textDisabled
```

**Step 2: Fix `lineLimit(1)` in `UnscheduledTodoRow`**

Find:
```swift
.lineLimit(1)
.frame(maxWidth: .infinity, alignment: .leading)
```

Replace with:
```swift
.lineLimit(2)
.truncationMode(.tail)
.fixedSize(horizontal: false, vertical: true)
.frame(maxWidth: .infinity, alignment: .leading)
```

**Step 3: Fix section header style**

Find in `unscheduledSection`:
```swift
Text("UNSCHEDULED")
    .font(AppTheme.caption)
    .foregroundColor(AppTheme.textSecondary)
    .kerning(0.5)
```

Replace with:
```swift
Text("Unscheduled")
    .font(AppTheme.label)
    .foregroundColor(AppTheme.textPrimary)
```

**Step 4: Fix responsiveness — replace fixed maxHeight with layout priority**

Find the `unscheduledSection` call site in `body`:
```swift
// Unscheduled todos
unscheduledSection

Divider()

// Search bar
searchBar
```

Replace with:
```swift
// Unscheduled todos
unscheduledSection
    .layoutPriority(0)

Divider()

// Search bar
searchBar
```

Then inside `unscheduledSection`, find:
```swift
ScrollView {
    LazyVStack(spacing: 0) {
        ForEach(unscheduledTodos) { todo in
            UnscheduledTodoRow(todo: todo, appState: appState) {
                runningTodo = todo
            }
            Divider().padding(.leading, AppTheme.lg)
        }
    }
}
.frame(maxHeight: 200)
```

Replace with:
```swift
ScrollView {
    LazyVStack(spacing: 0) {
        ForEach(unscheduledTodos) { todo in
            UnscheduledTodoRow(todo: todo, appState: appState) {
                runningTodo = todo
            }
            Divider().padding(.leading, AppTheme.lg)
        }
    }
}
.frame(maxHeight: 280)
```

(280 is more generous but still prevents the list from pushing out the calendar.)

Also give the calendar grid higher layout priority so it won't get squished. Find the `calendarGrid` call site:
```swift
// Calendar grid
calendarGrid
    .padding(.horizontal, AppTheme.lg)
    .padding(.vertical, AppTheme.md)
```

Replace with:
```swift
// Calendar grid
calendarGrid
    .padding(.horizontal, AppTheme.lg)
    .padding(.vertical, AppTheme.md)
    .layoutPriority(1)
```

**Step 5: Build**

```bash
make
```
Expected: `Built build/AutoClawd.app` — no errors.

**Step 6: Commit**

```bash
git add Sources/WorldView.swift
git commit -m "fix: textDisabled for dim cells, lineLimit(2) todos, section header, layout priority"
```

---

## Task 6: IntelligenceConsolidatedView — fix logs

**Files:**
- Modify: `Sources/IntelligenceConsolidatedView.swift`

**Context:**
`loadLogs()` looks for `~/.autoclawd/autoclawd.log` which doesn't exist. The logger writes to `~/.autoclawd/logs/autoclawd-YYYY-MM-DD.log` AND keeps up to 500 entries in-memory via `AutoClawdLogger.shared.snapshot()`.

The new logs view:
- Tries `AutoClawdLogger.shared.snapshot()` first (always populated while app is running)
- Falls back to reading today's log file
- Displays entries as a coloured list (ERROR=red, WARN=orange, INFO=secondary, DEBUG=disabled) rather than a wall of raw text
- Has a "Refresh" button in the sub-tab header

**Step 1: Add `logEntries` state and replace `logContent`**

Find at the top of `IntelligenceConsolidatedView`:
```swift
@State private var logContent: String = ""
```

Replace with:
```swift
@State private var logEntries: [LogEntry] = []
```

**Step 2: Replace `loadLogs()`**

Find the entire `loadLogs()` function:
```swift
private func loadLogs() {
    // Try common AutoClawd log paths
    let candidates: [URL] = [
        FileManager.default.homeDirectoryForCurrentUser
            .appendingPathComponent(".autoclawd/autoclawd.log"),
        FileManager.default.urls(for: .applicationSupportDirectory, in: .userDomainMask)
            .first?.appendingPathComponent("AutoClawd/autoclawd.log") ?? URL(fileURLWithPath: "/dev/null")
    ]
    for url in candidates {
        if let content = try? String(contentsOf: url, encoding: .utf8), !content.isEmpty {
            logContent = content
            return
        }
    }
}
```

Replace with:
```swift
private func loadLogs() {
    // 1. In-memory snapshot (always available while app is running)
    let entries = AutoClawdLogger.shared.snapshot(limit: 500)
    if !entries.isEmpty {
        logEntries = entries.reversed() // newest first
        return
    }
    // 2. Fallback: parse today's log file
    let f = DateFormatter()
    f.dateFormat = "yyyy-MM-dd"
    let dateStr = f.string(from: Date())
    let url = FileManager.default.homeDirectoryForCurrentUser
        .appendingPathComponent(".autoclawd/logs/autoclawd-\(dateStr).log")
    guard let raw = try? String(contentsOf: url, encoding: .utf8), !raw.isEmpty else { return }
    // Display raw lines as pseudo-entries when snapshot is empty
    logEntries = raw.components(separatedBy: "\n")
        .filter { !$0.isEmpty }
        .reversed()
        .map { line in
            LogEntry(timestamp: Date(), level: .info, component: .system, message: line)
        }
}
```

**Step 3: Replace `logsContent` view**

Find the entire `logsContent` computed property:
```swift
private var logsContent: some View {
    ScrollView {
        Text(logContent.isEmpty ? "No logs yet." : logContent)
            .font(AppTheme.mono)
            .foregroundColor(logContent.isEmpty ? AppTheme.textSecondary : AppTheme.textPrimary)
            .frame(maxWidth: .infinity, alignment: .leading)
            .padding(AppTheme.lg)
            .textSelection(.enabled)
    }
    .background(AppTheme.surface)
}
```

Replace with:
```swift
private var logsContent: some View {
    Group {
        if logEntries.isEmpty {
            emptyState(icon: "doc.text", message: "No logs yet.")
        } else {
            ScrollView {
                LazyVStack(alignment: .leading, spacing: 0) {
                    ForEach(logEntries.indices, id: \.self) { i in
                        logRow(logEntries[i])
                        if i < logEntries.count - 1 {
                            Divider().opacity(0.4)
                        }
                    }
                }
                .padding(AppTheme.md)
            }
        }
    }
    .background(AppTheme.surface)
}

private func logRow(_ entry: LogEntry) -> some View {
    HStack(alignment: .top, spacing: AppTheme.sm) {
        Text(shortTime(entry.timestamp))
            .font(AppTheme.mono)
            .foregroundColor(AppTheme.textDisabled)
            .frame(width: 60, alignment: .leading)

        Text(entry.level.rawValue)
            .font(.system(size: 10, weight: .semibold))
            .foregroundColor(levelColor(entry.level))
            .frame(width: 36, alignment: .leading)

        Text("[\(entry.component.rawValue)]")
            .font(AppTheme.mono)
            .foregroundColor(AppTheme.textSecondary)
            .frame(width: 80, alignment: .leading)

        Text(entry.message)
            .font(AppTheme.mono)
            .foregroundColor(AppTheme.textPrimary)
            .textSelection(.enabled)
            .frame(maxWidth: .infinity, alignment: .leading)
            .fixedSize(horizontal: false, vertical: true)
    }
    .padding(.vertical, AppTheme.xs)
    .padding(.horizontal, AppTheme.sm)
}

private func levelColor(_ level: LogLevel) -> Color {
    switch level {
    case .error: return AppTheme.destructive
    case .warn:  return .orange
    case .info:  return AppTheme.textSecondary
    case .debug: return AppTheme.textDisabled
    }
}

private func shortTime(_ date: Date) -> String {
    let f = DateFormatter()
    f.dateFormat = "HH:mm:ss"
    return f.string(from: date)
}
```

**Step 4: Add Refresh button to the logs tab header**

Find in the sub-tab header `HStack`:
```swift
if subTab == .extractions {
    extractionActions
        .padding(.trailing, AppTheme.lg)
}
```

Replace with:
```swift
if subTab == .extractions {
    extractionActions
        .padding(.trailing, AppTheme.lg)
} else if subTab == .logs {
    Button {
        loadLogs()
    } label: {
        Label("Refresh", systemImage: "arrow.clockwise")
            .font(AppTheme.caption)
    }
    .buttonStyle(SecondaryButtonStyle())
    .controlSize(.small)
    .padding(.trailing, AppTheme.lg)
}
```

**Step 5: Update `onAppear` to use `loadLogs()` (already called, nothing to change)**

Double-check `onAppear` already calls `loadLogs()` — it does (line 66 in original). No change needed.

**Step 6: Build**

```bash
make
```
Expected: `Built build/AutoClawd.app` — no errors.

**Step 7: Commit**

```bash
git add Sources/IntelligenceConsolidatedView.swift
git commit -m "fix: logs tab reads from AutoClawdLogger.snapshot() + correct file path, coloured rows"
```

---

## Task 7: SettingsConsolidatedView — section headers, tag font, path truncation, appearance picker

**Files:**
- Modify: `Sources/SettingsConsolidatedView.swift`

**Context:**
Four fixes:
1. `sectionHeader()` renders at `caption + textSecondary` — barely readable. Change to standard macOS style: 11pt semibold + textSecondary + uppercase tracking.
2. Project tags at 10pt — too small. → 12pt.
3. Project path `lineLimit(1)` cuts off long paths silently. → keep 1 line but use `.truncationMode(.middle)` so the filename stays visible.
4. Add appearance picker (System/Light/Dark) in the Display section.

**Step 1: Find and update the `sectionHeader` function**

Search for the `sectionHeader` function (it's a private helper, likely near the bottom or used inline). It will look something like:

```swift
private func sectionHeader(_ title: String) -> some View {
    Text(title)
        .font(AppTheme.caption)
        .foregroundColor(AppTheme.textSecondary)
        .frame(maxWidth: .infinity, alignment: .leading)
}
```

Replace with:
```swift
private func sectionHeader(_ title: String) -> some View {
    Text(title.uppercased())
        .font(.system(size: 11, weight: .semibold))
        .foregroundColor(AppTheme.textSecondary)
        .kerning(0.3)
        .frame(maxWidth: .infinity, alignment: .leading)
        .padding(.top, AppTheme.sm)
}
```

**Step 2: Fix project tag font size**

Find:
```swift
.font(.system(size: 10, weight: .medium))
```

Replace with:
```swift
.font(.system(size: 12, weight: .medium))
```

**Step 3: Fix project path truncation**

Find:
```swift
Text(project.localPath)
    .font(AppTheme.caption)
    .foregroundColor(AppTheme.textSecondary)
    .lineLimit(1)
```

Replace with:
```swift
Text(project.localPath)
    .font(AppTheme.caption)
    .foregroundColor(AppTheme.textSecondary)
    .lineLimit(1)
    .truncationMode(.middle)
```

**Step 4: Add appearance picker to the Display section**

First, add state at the top of `SettingsConsolidatedView`:
```swift
@AppStorage("color_scheme_setting") private var colorSchemeSetting: String = "system"
```

Then find the Display section (it currently has mic/audio or similar UI). Find the `sectionHeader("DISPLAY")` call and the content below it. Add the appearance picker as the first item:

```swift
// Appearance
HStack {
    Text("Appearance")
        .font(AppTheme.label)
        .foregroundColor(AppTheme.textPrimary)
    Spacer()
    Picker("", selection: $colorSchemeSetting) {
        ForEach(ColorSchemeSetting.allCases, id: \.rawValue) { setting in
            Text(setting.displayName).tag(setting.rawValue)
        }
    }
    .pickerStyle(.segmented)
    .frame(width: 200)
}
```

**Step 5: Build**

```bash
make
```
Expected: `Built build/AutoClawd.app` — no errors.

**Step 6: Commit**

```bash
git add Sources/SettingsConsolidatedView.swift
git commit -m "fix: section headers, tag font 12pt, path middle-truncation, appearance picker"
```

---

## Final Step: Push

```bash
git push origin main
```

---

## Worktree Setup

Before starting, create and enter a worktree:

```bash
cd "/Users/sameeprehlan/Documents/Claude Code/autoclawd"
git worktree add .claude/worktrees/ui-polish -b claude/ui-polish
```

Work inside `.claude/worktrees/ui-polish` for all tasks. At the end, merge back:

```bash
git checkout main
git merge claude/ui-polish
git push origin main
git worktree remove .claude/worktrees/ui-polish
git branch -d claude/ui-polish
```
